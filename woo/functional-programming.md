# 계층형 설계 1

## 계층형 설계란?
- 계층형 설계는 소프트웨어를 계층으로 구성하는 기술
- 각 계층의 함수는 바로 아래 계층의 함수로 구성된다.
- 다음과 같은 계층들이 생길 수 있다.
    - Layer 1: 비즈니스 규칙
    - Layer 2: 장바구니를 위한 동작들
    - Layer 3: 카피-온-라이트
    - Layer 4: 언어에서 지원하는 배열 관련 기능
- 단, 각 계층을 나누는 절대적인 기준은 없다.

## 계층형 설계 패턴
- 계층형 설계에는 크게 4가지 패턴이 존재한다.
    - 직접 구현: 함수 시그니처가 나타내는 문제를 함수 본문에서 적절한 구체화 수준으로 해결한다.
    - 추상화 벽: 호출 그래프에 특정 계층은 세부 구현은 감추고 인터페이스만 제공하여 고수준의 추상화 단계만 생각해도 되도록 돕는다.
    - 작은 인터페이스: 비즈니스 개념을 나타내는 중요한 인터페이스를 작고 강력하게 구성하려고 노력한다.
    - 편리한 계층: 각 계층은 비즈니스 문제를 잘 풀 수 있도록 구현해야 하고 도움이 될 때 시간을 투자해야 한다.

## 패턴 1: 직접 구현
- 직접 구현 패턴이은 함수의 구현부가 적절한 계층의 함수를 호출하여 해결할 수 있또록 구성하는 것
- 상위 계층을 호출해서는 안 되고, 계층을 너무 많이 건너 뛰어 아래 계층을 호출하는 것도 지양해야 한다.
- 그 이유는 계층을 올라갈 수록 여러 문제가 해결된 함수를 사용하여 해당 계층에서 고민하는 문제를 줄여 개발에 편리한 구조를 만들기 위함이라 이해했다.
  <br></br>

```javascript
function isInCart(cart, name) {
  for (var i = 0; i < cart.length; i++) {
    if (cart[i].name === name) {
      return true;
    }
  }
  
  return false;
}

function indexOfItem(cart, name) {
  for (var i = 0; i < cart.length; i++) {
    if (cart[i].name === name) {
      return i;
    }
  } 
  
  return null;
}
```
- 위 2개의 메서드는 각기 다른 계층에 존재하는 메서드이다.
- isInCart는 장바구니를 위한 동작들이 정의된 계층이고, indexOfItem은 일종의 배열의 기능을 제공하는 계층으로 isInCart가 더 높은 계층에 위치한다.
- 하지만 위 구조를 보면 isInCart는 바로 아래 계층을 건너 뛰고 언어에서 지원하는 기능을 직접 호출하고 있다.

<br></br>

```javascript
function isInCart(cart, name) {
  return indexOfItem(cart, name) !== null
}
```
- 위와 같이 정의하면 계층들이 모두 바로 아래 계층을 호출하는 구조가 된다.
- 또한 장바구니를 위한 동작인 isInCart를 구현하며 배열과 관련된 구현 로직을 고민하지 않아도 되기 때문에 개발 생산성이 더 높아질 것을 기대할 수 있다.

## 직접 구현 패턴의 장/단점 및 생각
- 함수를 읽을 때 알아야 할 구체화 로직의 범위가 제한되기 때문에 가독성 측면에서 뛰어나다. (단, 바로 아래 계층의 인터페이스를 기준으로 로직을 파악하면 된다.)
- 추가적인 도구로 호출 그래프를 활용하여 계층과 함수 관계를 쉽게 파악할 수 있고 계층 기준으로 파악하며 리팩토링의 단서를 찾을 수도 있다.
- 직접 구현 패턴을 사용하면 더 일반적인 함수를 만들도록 노력하게 되고 이는 함수의 재사용성 측면에서 장점을 가질 수 있다.
- 단, 계층 자체가 복잡성의 일부가 될 수 있을 것 같다. 업무에 적용해보기 위해서는 계층에 대한 정의와 프로젝트에 적용할 계층에 정의를 모두가 숙지하고 있어야 할 것 같다.

# 계층형 설계 2

## 패턴 2: 추상화 벽
- 추상화 벽은 세부 구현을 감춘 함수로 이루어진 계층을 뜻한다.
- 타 팀에서 제공하는 API를 생각해보면 이해가 쉽다. 이용부는 API Spec만 알 뿐 구체적인 구현은 모른다.
- 이런 구조에서는 아래와 같은 이점을 얻을 수 있다.
    - 쉽게 구현부을 변경할 수 있다.
    - 사용부에서 세부적인 것을 고려하지 않아도 되기 때문에 코드를 읽고, 쓰기 쉬워진다.
    - 협업 시에 각 팀의 구체적인 작업에 대해서는 서루 알 필요가 사라진다.
    - 세부적인 것을 고려하지 않을 수 있기 때문에 코드를 읽고 쓰는 작업 중에 현재 함수에서 풀고자 하는 문제에 더 집중할 수 있다.
- 각 계층에서 신경써야하는 것과 신경쓰지 않아도 되는 것을 구분하는 것이 추상화 벽의 핵심

## 패턴 3: 작은 인터페이스
- 작은 인터페이스는 기능이 추가될 때 어떤 계층에 부합하는지 고민하고, 각 계층에서 최소한의 기능만을 제공하여 크기를 최소한으로 조절하는 것을 지향하는 것이다.
- 계층에서 제공하는 기능이 많아질 경우 아래와 같은 문제가 발생할 수 있다.
    - 각 계층에 기능이 많을수록 구현이 변경되었을 때 고쳐야 할 것이 많아진다.
    - 기능이 많을 수록 상위 계층과 조율이 필요한 부분이 많이 발생한다.
    - 또한 알아야 할 기능도 많아진다.
- 즉, 기능을 최소한으로 두고 새로운 기능이 필요할 경우 상위 계층에서 현재 제공되는 기능의 조합으로 만드는 것을 고려해보면 된다.
- 만약 현재 제공하는 기능을 조합하여 상위 계층에 만들 수 있는 기능이라면, 기능의 구체성을 고려할 때 상위 계층이 적합할 것이다.
- 또한 이 방향성이 직접 구현 패턴에도 더 부합한다.

## 패턴 4: 편리한 계층
- 편리한 계층 패턴은 언제 1, 2, 3 패턴들을 적용하고 멈춰야 하는지에 대한 해답을 제시해준다.
- 기준은 자신과 팀원들이 작업하기 편리한 코드라고 느끼는지 여부이다.
- 언제나 설계와 새로운 기능의 필요성 어느 지점 사이에 머물게 되는데, 어느 방향에 힘을 줄 지를 결정할 기준을 제시해준다.


## 함수 호출 그래프로 알아보는 유지 보수성 / 테스트성 / 재사용성
- 계층형 설계를 설명하며 책에서는 함수 호출 그래프를 자주 제시한다.
- 호출 그래프를 보면 모든 함수를 계층에 기반하여 구조적으로 조망할 수 있다.
- 이때 계층에 따라 상/하위 함수들이 존재하게 된는데, 위치에 따라 유지보수성/테스트성/재사용성을 간단히 구별할 수 있다.
    - 유지보수성: 상위 계층의 함수가 가장 고치기 쉽고 하위 계층은 그 반대이다.
    - 테스트성: 하위 계층의 함수일수록 테스트의 가치가 높고 상위 계층은 그 반대이다.
    - 재사용성: 하위 계층의 함수일수록 재사용성이 높고 상위 계층은 그 반대이다.
- 여기서 유지보수성은 왜 외부에 노출되는 메서드가 상위 계층에 존재하는지를 이해할 수 있게 해준다. (변경 요구가 많을 것이기 때문이다.)