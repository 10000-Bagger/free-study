# MySQL 파티션
## 1. 파티셔닝이란?
파티션은 논리적으로 하나인 테이블을 물리적으로 여러 테이블로 분리해 사용하는 것을 말한다. <br>
사용하는 입장에선 하나의 테이블이지만, 실제 데이터들은 여러 군데에 나뉘어 있는 것이다. 예를 들어 지구인들을 DB로 관리한다고 가정했을 때, 하나의 테이블이 너무 커지는 경우 탐색 속도가 매우 느려질 수 있으므로, 태어난 년도별로 테이블을 나누어 저장하는 것이다. <br>

## 2. 언제 사용하면 좋냐?
이는 데이터가 너무 많아져 인덱스 테이블이 커지는 경우에 아주 좋다. 인덱스 테이블은 데이터가 조금만 많아져도 필수적인데, 이 인덱스 테이블이나 원본 테이블에서 자주 호출되는 데이터들이 DB 서버의 물리적인 메모리 보다도 커서 한번에 올려 놓기 힘든 경우 탐색이 아주 아주 느려질 수 밖에 없다. <br> 파티셔닝은 이런 경우에 특히 좋다. 데이터를 나눈 만큼, 인덱스 테이블 또한 나누어져 크기가 작아지기 때문이다. <br> 이 책에선 이렇게 "자주 쓰여지는 데이터"를 Working Set이라고 부르니 참고하자. 전통 OS 책에서 말하는 Working Set과는 미묘하게 다른 것 같기도 하고.. <br>

이 책에서는 결국 DB는 활발하게 사용되는 부분이 정해져 있는 경우가 많으므로, Working Set을 파티셔닝 하면 좋다고 말한다. 예를 들어 SNS의 경우 가장 최근 20% 가량의 데이터가 자주 조회되지, 오래된 글들은 조회가 굉장히 낮을 것이다. <br>

![image](https://github.com/10000-Bagger/free-topic-study/assets/71186266/f07de29e-df65-4f3a-857a-c3cba349b839)


전통 OS 책에서 말하는 Working Set이랑은 조금 다른데 원래 Working Set은 프로세스가 원활하게 수행되기 위해 메모리에 한번에 올라와 있어야 하는 page들의 set을 Working Set이라고 한다. <br> 나는 공구함을 떠올렸다. 공구함이 넉넉해야 사다리 위 작업자가 오르락 내리락 반복을 덜 할 수 있지 않겠는가? <br> 
 더 알아보고 싶으면 Thrashing과 Working-Set 알고리즘을 찾아보자. <br> <br> 

또 파티셔닝은 주기적인 삭제 작업이 필요한 경우에 좋다. <br> 
예를 들어 로그 데이터가 너무 방대해서 연도별로 파티셔닝 하여 모아놨다고 가정해보자. 그리고 5년이 지난 데이터는 한번에 지운다. 이 경우 파티셔닝 된 2019년도 로그 테이블만 날리면 된다. 파티셔닝이 없는 경우, 그 방대한 테이블 안에서 2019년도 로그를 찾아야 했을 것이다. 

### Horizontal vs Vertical Partitioning
사실 계속 언급한 방식의 파티셔닝은 Horizontal Partitioning이라고 수평 분할에 해당하는데 이 책에서는 수평 분할만을 언급한다. 테이블을 Column 기준으로 분할하는 "Vertical Partitioning"도 있으니, 궁금한 사람은 찾아보자. <br>
이 글에서 앞으로 "파티셔닝"이라고 표현하는 것은 Horizontal한 파티셔닝이라고 생각하면 좋겠다.

## 3. 파티셔닝 테이블에서의 쿼리 실행
파티셔닝을 좀 더 제대로 이해하기 위해, 파티셔닝이 적용된 테이블의 INSERT와 SELECT 등의 쿼리가 어떻게 실행되는지를 살펴보자. <br>
쿼리별로 어떻게 동작하는지를 정확히 알아야 제대로 된 성능 향상을 얻을 수 있다. <br> 

### 기본 상황 설명
게시물 테이블이 있다고 가정하자. 그리고 게시물의 작성 일자 created_at이 관리 기준이라고 생각하자. 예를 들어 데이터는 작성 년도에 따라 다른 테이블에 저장된다. **이를 `파티션 키`라고 부른다.** 

### INSERT
Insert의 경우 기준이 되는 "작성 년도"를 먼저 확인하게 될 것이다. 이 "작성 년도" 값을 이용해 파티션 표현식을 평가한다. (들어가게 될 테이블을 결정한다는 뜻) 이후 나머지는 일반적인 테이블과 똑같이 진행된다.

### UPDATE :star:
Update의 경우에도 똑같이 테이블을 찾아야 한다. **문제는 Update 쿼리의 WHERE 조건에 파티션 키 칼럼이 존재하느냐다.** 
- 포함된 경우 : 해당 칼럼을 이용해 파티션을 빠르게 찾아낼 수 있다. 
- 포함되지 않은 경우 : **모든 파티션을 검색해야 한다.**

<Br>

**또한, 파티션 키로 사용중인 값을 변경하는 경우 파티션도 변경해야 한다!** 일단 기존 칼럼을 삭제하고, 변경된 파티션 키로 새로운 파티션을 결정한다.  <br> <br>


## 4. 검색 성능에 영향을 미치는 요소
결국 성능에서 제일 걸림돌이 되는건 파티션의 선택이다. <br>
1. 쿼리의 WHERE절의 조건으로 파티션을 선택할 수 있는가
2. WHERE 절의 조건이 인덱스를 효율적으로 사용하는가? (인덱스 레인지 스캔이 가능한가?)

위 두 요소가 큰 영향을 미친다. 두번째 요소는 어짜피 파티셔닝과 무관하긴 하지만, 1번 요소의 결과에 의해 내용이 달라질 수 있다. <br> <br>

간단하게 살펴보자.  

1. `파티션 선택 O` + `인덱스 효율적 O` : 꼭 필요한 파티션에서 인덱스 레인지 스캔! 가장 효율적!
2. `파티션 선택 X` + `인덱스 효율적 O` : **모든 파티션에 대해 검색해야 한다.** 그나마 파티션별 인덱스 레인지 스캔을 사용하지만, 파티션 갯수만큼 검색한 다음에 결과를 병합해야 한다. (정렬까지 있다면 더욱 끔찍..)
3. `파티션 선택 O` + `인덱스 효율적 X` : 한 파티션에 대해 풀 테이블 스캔한다! 파티션의 레코드 갯수가 관건..
4. `파티션 선택 X` + `인덱스 효율적 X` : 지옥. 모든 파티션 풀 테이블 스캔


<br> <br>

4가지 상황 중에 아래 상황을 조심하자 
1. 3, 4번은 가급적 피할 것 
2. 2번 상황 또한 파티션 개수가 많을 때는 부하가 크고 처리 시간이 느리므로 주의하자. 

<br>
