## 마이크로 프론트엔드 아키텍처

### module federation

- 마이크로 프론트엔드 아키텍처의 구현 방식 중 하나
- 하나의 앱을 독립적인 배포가 가능한 모듈 단위로 나누어 브라우저의 런타임 시점에 통합하는 방식
- 하나의 앱을 특정 단위로 나누어서 배포할 수 있음

#### 기존 앱들의 문제

- Sharing code is hard: 빌드타임 통합은 느리고 비효율적이며 확장 가능하지 않다
- Nothing Feels Smooth: 자주 쓰이던 런타임 통합 방식은 결국 하나의 앱처럼 합쳐지지 않는다
- Native ESM은 아직 브라우저에서 느리고
- Monolith는 확장하면 할수록 커지고 느려지고
- webpack external을 사용해 특정 모듈을 따로 번들링하는 것은 수고롭다.

#### Webpack 5 Module Federation Plugin

- [2020년에 릴리즈된 웹팩5](https://webpack.js.org/blog/2020-10-10-webpack-5-release/#module-federation)에 추가되었다.
- 해당 플러그인을 사용하면 청크로 잘게 나눠놓은 JS 모듈들의 런타임 로드가 제대로 동작할 수 있다.
- 빌드 시, 코드를 직접 수정하고 추가하거나 청크를 나누거나 청크 간의 의존관계를 바꾸는 등의 처리를 통해 청크 결과물을 처리한다.

### module federation의 3가지 개념

#### Container

- 다른 마이크로앱에서 로드 가능한 단위
- A앱을 B,C와 같은 마이크로 앱에서 불러와서 사용할 수 있으면 `A앱은 컨테이너를 포함하고 있다` 라고 말할 수 있다.

```js

// 아래 설명할 conatiner reference를 가진 다른 micro app에서는
// 다음과 같은 방식으로 microApp을 불러옵니다.
​
import 구현체 from '{container 이름}/{exposes설정값의 key}';
​
// 정적 import
import MicroAppA from 'microApp/AppA';
​
// 동적 import
const MicroAppB = React.lazy(() => import('microApp/AppB'));
```

#### Container References

- 특정 앱에서 다른 마이크로 앱을 imort할 때 만들어지는 참조 관계
- A 앱에서 B 앱을 import해서 쓰고 있다면 `A앱은 B앱에 대한 Container Refrences가 존재한다.`고 말할 수 있다.

#### Share Scope

- 공유되는 의존성이 유효한 하나의 스코프
- 마이크로 앱 간 의존성 공유를 할 때, 공유 의존성에 대한 설정, 버전을 체크하고 이를 설정한 바에 맞게 각 마이크로 앱에 로드해서 쓰는 방식을 결정
- `shared` 설정으로 특정 의존성과 버전을 넘기면 마이크로 앱 간 의존성을 런타임에서 공유할 수 있다.
- `shareScope` 설정까지 넘겨주면 같은 스코프를 가지고 있는 container, container reference 사이에서만 의존성을 공유할 수 있다.

---

이를 통해빌드 타임이 아닌 런타임에 각 분리된 앱을 합치는 방식으로, 분리된 앱들이 자바스크립트 번들 형태로 배포된다.

각각의 앱들은 호스트라고 불리는 앱에서 번들 형태로 로드되어 각각 따로 렌더링 된다.

이를 통해 화면에 보이는 모든 UI를 컴포넌트 단위로 배포할 수 있다. 앱 전환 시에는 모든 자원을 처음부터 다시 불러올 필요가 없고, 런타임 환경에서 하나의 앱을 사용하는 것처럼 만들 수 있다.

```
개발 -> 테스트/CI -> 빌드 -> Remote A -(런타임 번들 로드)> Host(Remote A)

개발 -> 테스트/CI -> 빌드 -> Remote B -(런타임 번들 로드)> Host(Remote B)
```

- 배포 단위를 잘게 쪼개서 필요한 부분만 개발하고 배포하는 방식으로 변경 가능하여 독립적인 개발이 가능하다.
