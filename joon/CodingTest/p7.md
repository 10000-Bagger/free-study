# 알고리즘 문제 풀이

## [빌런 호석 (백준 22251)](https://www.acmicpc.net/problem/22251)

## 문제

치르보기 빌딩은 `1`층부터 `N`층까지 이용이 가능한 엘리베이터가 있다.<br/>
엘리베이터의 층수를 보여주는 디스플레이에는 `K` 자리의 수가 보인다.<br/>
수는 `0`으로 시작할 수도 있다.<br/>
`0`부터 `9`까지의 각 숫자가 디스플레이에 보이는 방식은 아래와 같다.<br/>
각 숫자는 `7`개의 표시등 중의 일부에 불이 들어오면서 표현된다.

<img src="https://upload.acmicpc.net/fcb7dfaf-672b-48c4-bb25-7adf16fe106e/-/preview/" height="100"></img>

예를 들어 `K=4`인 경우에 `1680`층과 `501`층은 아래와 같이 보인다.

<img src="https://upload.acmicpc.net/ad62e659-8aef-4284-bd13-47df4a4ccbca/-/preview/" height="100"></img>

빌런 호석은 치르보기 빌딩의 엘리베이터 디스플레이의 LED 중에서 최소 1개, 최대 `P`개를 반전시킬 계획을 세우고 있다.<br/>
반전이란 켜진 부분은 끄고, 꺼진 부분은 켜는 것을 의미한다.<br/>
예를 들어 숫자 `1`을 `2`로 바꾸려면 총 5개의 LED를 반전시켜야 한다.<br/>
또한 반전 이후에 디스플레이에 올바른 수가 보여지면서 `1` 이상 `N` 이하가 되도록 바꿔서 사람들을 헷갈리게 할 예정이다.<br/>
치르보기를 사랑하는 모임의 회원인 당신은 호석 빌런의 행동을 미리 파악해서 혼쭐을 내주고자 한다.<br/>
현재 엘리베이터가 실제로는 `X`층에 멈춰있을 때, 호석이가 반전시킬 LED를 고를 수 있는 경우의 수를 계산해보자.

$1 ≤ X ≤ N < 10^K$

$1 ≤ K ≤ 6 $

$1 ≤ P ≤ 42 $

## 풀이

처음 문제를 읽고, 각 자리별로 반전시킬 수 있는 LED가 K개인줄 알고 문제에 접근하였다.<br/>
하지만 K가 최대 6이기 때문에 각 자리별로 6개의 LED를 변환한다면 모든 수를 다 만들 수 있기 때문에 문제를 다시 읽고 접근하였다.<br/>
그러고 보니 각 자리별로 LED를 반전시킨 수가 K개 이하일 때 만들어질 수 있는 수를 찾는 문제로 이해하였다.

7 세그먼트는 특정 규칙이 있는 배열로 만들기 어렵기 때문에, 길이가 9인 배열 10개를 이용하여 숫자를 표현하였다. <br/>
각 세그먼트의 자리에 해당하는 배열의 인덱스는 다음과 같다.

```
   1
   -
0 | | 2
   -  <-- 4
3 | | 5
   -  <-- 7
 (6 8)
```

마지막 줄에 6과 8은 비우고, 7을 가장 아래 세그먼트로 표기한 이유는 그냥 내 기준으로 헷갈리지 않기 위해 여백을 추가하였다.<br/>
이렇게까지 세팅하고 나서 문제는 금방 풀렸다.<br/>
문제를 푸는 것보다 이렇게 세그먼트들을 세팅하는 것을 생각하는데 더 많은 시간을 사용한 것 같다.<br/>
이제 이렇게 세그먼트 표기 규칙을 만들었으니 0~9까지의 숫자를 세그먼트로 표기하여 배열에 담아두었다.

이후에는 **완전 탐색**으로 1층부터 N층까지의 수를 X와 비교를 하는데, 각 수의 자리 별로 세그먼트화하여 세그먼트 차이가 몇 개 나는지를 종합하고, 이 차이가 P 이하일 때 정답을 카운트하였다.<br/>
완전 탐색으로 문제를 푼 이유는 `(최대 100만) * (최대 k = 6) * (세그먼트 수 = 9)`로 시간복잡도는 충분하다고 판단하였기 때문이다.

## 코드

```cpp
#include <iostream>

using namespace std;

int n, k, p, x;
int segments7[10][9] =
  {
    {1,1,1, // 0
     1,0,1,
     0,1,0
    },
    {0,0,1, // 1
     0,0,1,
     0,0,0
    },
    {0,1,1, // 2
     1,1,0,
     0,1,0
    },
    {0,1,1, // 3
     0,1,1,
     0,1,0
    },
    {1,0,1, // 4
     0,1,1,
     0,0,0
    },
    {1,1,0, // 5
     0,1,1,
     0,1,0
    },
    {1,1,0, // 6
     1,1,1,
     0,1,0
    },
    {0,1,1, // 7
     0,0,1,
     0,0,0
    },
    {1,1,1, // 8
     1,1,1,
     0,1,0
    },
    {1,1,1, // 9
     0,1,1,
     0,1,0
    },
  };

int main() {
  int cnt = 0;

  cin >> n >> k >> p >> x;

  for(int i = 1 ; i <= n ; i++) {
    int src = x, dest = i, diff = 0;

    if(i == x) continue;

    for(int  j = 0 ; j < k ; j++) {
      int current = src % 10;
      int next = dest % 10;

      for(int l = 0 ; l < 9 ; l++) {
        if(l == 6 || l == 8) continue;
        if(segments7[current][l] != segments7[next][l]) diff++;
      }

      src /= 10;
      dest /= 10;
    }

    if(diff <= p) cnt++;
  }

  cout << cnt << '\n';
  return 0;
}
```
