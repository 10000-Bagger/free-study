# 알고리즘 문제 풀이

## [평범한 배낭 (백준 12865)](https://www.acmicpc.net/problem/12865)

## 문제

이 문제는 아주 평범한 배낭에 관한 문제이다.

한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다.<br/>
세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.

준서가 여행에 필요하다고 생각하는 N개의 물건이 있다.<br/>
각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다.<br/>
아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다.<br/>
준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.

N: 1 ≤ N ≤ 100
K: 1 ≤ K ≤ 100,000
W: 1 ≤ W ≤ 100,000

## 풀이

그 유명하고 유명한 Knapsack Problem.<br/>
학부시절 이 놈 때문에 알고리즘을 때려치고 싶었다.<br/>
다시 한번 차근차근 풀어보고자 했지만 역시나 그지같다.

우선 풀이는 다음과 같다.<br/>
무조건 배낭을 가득 채우는 것이 좋기 때문에 어떻게든 배낭을 가득 채운다고 가정한다.<br/>
그리고 점화식으 세우면 아래와 같다.

> dp[i][j] = max( dp[ i - 1 ][ j ], dp[ i - 1 ] j - w[ i ] ] + v[ i ] )

- i번째 물건을 넣고 이때 가방의 무게가 j일 때 가치의 최대값 : `dp[ i ][ j ]`
- 가방에 물건을 넣지 않는 경우: `dp[ i - 1 ][ j ]`
- 가방에 물건을 넣은 경우: `dp[ i - 1 ] j - w[ i ] ] + v[ i ]
  - `j - w[ i ]` 무게의 최대값을 보는 이유는 다른 물건들로 해당 값만큼 채웠을때의 가치값을 확인해봤을 수 있기 때문이다.

이걸 예시를 통해 알아보자!<br/>
그냥 봤을떈 나도 잘 이해하지 못했다...

```cpp
[input]

n = 4
k = 7

3 6
4 8
5 12
6 13

```

```cpp
1) w = 3 v = 6

	 0 1 2 3 4 5 6 7
	----------------
0| 0 0 0 0 0 0 0 0
1| 0 0 0 6 0 0 0 0
2| 0 0 0 6 0 0 0 0
3| 0 0 0 6 0 0 0 0
4| 0 0 0 6 0 0 0 0

2) w = 4 v = 8

	 0 1 2 3 4 5 6  7
	-----------------
0| 0 0 0 0 0 0 0  0
1| 0 0 0 6 0 0 0  0
2| 0 0 0 6 8 0 0 14
3| 0 0 0 6 8 0 0 14
4| 0 0 0 6 8 0 0 14

3) w = 5 v = 12

	 0 1 2 3 4  5 6  7
	------------------
0| 0 0 0 0 0  0 0  0
1| 0 0 0 6 0  0 0  0
2| 0 0 0 6 8  0 0 14
3| 0 0 0 6 8 12 0 14
4| 0 0 0 6 8 12 0 14

4) w = 6 v = 13

	 0 1 2 3 4  5  6  7
	-------------------
0| 0 0 0 0 0  0  0  0
1| 0 0 0 6 0  0  0  0
2| 0 0 0 6 8  0  0 14
3| 0 0 0 6 8 12  0 14
4| 0 0 0 6 8 12 13 14

-> "14"
```

## 코드

```cpp
#include <iostream>
#include <vector>
#include <utility>
#include <algorithm>
#include <cmath>

using namespace std;

int dp[101][100001]; // dp[MAX_N][MAX_WEIGHT]

int main() {
  int n, k;
  vector<pair<int, int> > things;

  things.push_back(make_pair(0, 0));
  cin >> n >> k;
  for(int i = 0, w, v; i < n; i++) {
    cin >> w >> v;
    things.push_back(make_pair(w, v));
  }

  sort(things.begin(), things.end()); // 얘는 해도 그만 안해도 그만

  for(int i = 1 ; i <= n ; i++) {
    int currentWeight = things[i].first;
    int currentValue = things[i].second;

    for(int j = 1 ; j <= k ; j++) {
      if(j >= currentWeight) {
        dp[i][j] = max(dp[i-1][j], dp[i - 1][j - currentWeight] + currentValue);
      } else dp[i][j] = dp[i-1][j];
    }
  }

  cout << dp[n][k] << '\n';

  return 0;
}
```
