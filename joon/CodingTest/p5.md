# 알고리즘 문제 풀이

## [전력망 둘로 나누기 (프로그래머스 lv2)](https://school.programmers.co.kr/learn/courses/30/lessons/86971)

## 문제

n개의 송전탑이 전선을 통해 하나의 트리 형태로 연결되어 있습니다.<br/>
당신은 이 전선들 중 하나를 끊어서 현재의 전력망 네트워크를 2개로 분할하려고 합니다.<br/>
이때, 두 전력망이 갖게 되는 송전탑의 개수를 최대한 비슷하게 맞추고자 합니다.

송전탑의 개수 `n (2 이상 100 이하)`, 그리고 전선 정보`wires`가 매개변수로 주어집니다.<br/>
`wires`의 각 원소는 `[v1, v2]` 2개의 자연수로 이루어져 있으며, 이는 `전력망의 v1번 송전탑과 v2번 송전탑이 전선으로 연결되어 있다`는 것을 의미합니다.
전선들 중 하나를 끊어서 송전탑 개수가 가능한 비슷하도록 두 전력망으로 나누었을 때,<br/>
두 전력망이 가지고 있는 송전탑 개수의 차이(절대값)를 return 하도록 solution 함수를 완성해주세요.

## 풀이

예전 2020년도때 기업 코테를 보며 빈출로 봤고, 비슷한 유형이 많은 문제이다.<br/>
예전에는 단순 그래프 문제로만 생각하여 오히려 시간이 느리고 `n`이 커짐에 따라 아예 통과하지 못하는 경우도 존재했다.
따라서 나는 `BFS`를 활용하였다.

엣지 별로 탐색하며 `[src, dest]` 중 `dest`를 이미 방문했다고 가정하고 `src`부터 `bfs`를 실행한다.<br/>
`bfs`를 통해 노드 그룹의 개수를 카운트하고, 나머지 그룹과의 차이의 절대값을 구한다<br/>
절대값이 가장 작은 값을 `answer`에 저장하고 반환한다.

간만에 JavaScript로 문제를 풀었는데, BFS를 위한 Queue를 직접 구현해야 했다.<br/>
하지만 직접 구현하기 귀찮기도 했고, pop의 시간 복잡도가 O(1)까지는 되지 않지만, 스택 2개를 Queue 대신 사용해보았다.<br/>
push는 pushStack에 자유롭게 하되, pop을 할 때, 현재까지 pushStack에 들어가있는 아이템들을 모두 pop하여 popStack에 넣어주고 해당 스택에서 아이템을 꺼내쓰는 방식이다.

## 코드

```js
function solution(n, wires) {
  var answer = 100;
  const graph = Array.from(new Array(n + 1), () => new Array());
  let check;
  let pushStack = [];
  let popStack = [];

  const pop = () => {
    if (popStack.length === 0) {
      while (pushStack.length > 0) popStack.push(pushStack.pop());
    }
    return popStack.pop();
  };
  const push = (data) => {
    pushStack.push(data);
  };

  const bfs = (start) => {
    let cnt = 1;
    push(start);
    check[start] = 1;

    while (pushStack.length + popStack.length > 0) {
      const current = pop();

      for (let i = 0; i < graph[current].length; i++) {
        const next = graph[current][i];

        if (check[next]) continue;

        check[next] = 1;
        push(next);
        ++cnt;
      }
    }
    return cnt;
  };

  for (const [a, b] of wires) {
    graph[a].push(b);
    graph[b].push(a);
  }

  for (const [a, b] of wires) {
    popStack = [];
    pushStack = [];
    check = new Array(n + 1).fill(0);
    check[b] = 1;

    const cnt = bfs(a);
    const gap = Math.abs(n - cnt - cnt);
    answer = Math.min(answer, gap);
  }

  return answer;
}
```
