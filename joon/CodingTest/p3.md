# 코딩테스트 감살리기 프로젝트

## [RGB거리 (백준 1149)](https://www.acmicpc.net/problem/1149)

## 문제

길거리에 집이 `N`개 있다. (2 ≤ N ≤ 1,000) <br/>
각 집들을 규칙에 맞게 R, G, B 중 하나의 색으로 색칠하려고 한다. <br/>
각 집별로 집을 색칠하는 비용이 주어질 때, 규칙을 만족하며 모든 집을 색칠하는 비용의 최솟값은???

규칙은 다음과 같다.

- 1번 집의 색은 2번 집의 색과 같지 않아야 한다.
- N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
- i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.

## 풀이

문제를 보자마자 이건 DP다! 라고 느낌이 강하게 왔다. <br/>
조건에 맞춰 경우의 수를 따져보며 최솟값을 구해야하는데 `N`이 최대(1000)일 때, 첫 집을 제외하곤 이전 집에서 이미 고른 색을 제외한 두 색 중에 골라 칠해야하기 때문에 `3 * 2^(n-1)`로 시간복잡도가 매우 커질 것이기 때문이다.

이 문제는 각각의 케이스에서 경우의 수가 3개씩 존재하기 때문에 `[N * 3]` 크기의 2차원 배열을 사용하여 각 선택에 대한 최솟값을 저장하여 해결하였다.

`f(x, y)`를 **`x`번째 집을 `y`번째 색으로 색칠했을 때의 최솟값**이라고 한다면, 점화식은 다음과 같다.

```c++
1. f(x, 1) = min( f(x-1, 2), f(x-1, 3) ) + cost(x, 1)
2. f(x, 2) = min( f(x-1, 1), f(x-1, 3) ) + cost(x, 2)
3. f(x, 3) = min( f(x-1, 1), f(x-1, 2) ) + cost(x, 2)
```

최종적으로는 2차원 배열의 `N`번째 인덱스에서 3개의 최솟값 중 가장 작은 값을 반환해주면 정답이 된다.

## 코드

```C++
#include <iostream>
#include <cmath>

using namespace std;

#define MAXN 1000

int n;
int res = 987987987;
int cost[MAXN][3];
int dp[MAXN][3];

void solution() {
  // init
  for(int i = 0 ; i < 3 ; i++) {
    dp[0][i] = cost[0][i];
  }

  // solve
  for(int i = 1 ; i < n ; i++) {
    dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + cost[i][0];
    dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + cost[i][1];
    dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + cost[i][2];
  }

  // output
  for(int i = 0 ; i < 3 ; i++) {
    if(res > dp[n-1][i]) res = dp[n-1][i];
  }
}

int main() {
  cin >> n;

  for(int i = 0 ; i < n ; i++) {
    for(int j = 0 ; j < 3 ; j++) {
      cin >> cost[i][j];
    }
  }

  solution();
  cout << res << '\n';

  return 0;
}
```
