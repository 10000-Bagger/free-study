### View

- 웹 어플리케이션에서 가장 중요한 기능 중 하나는 **데이터의 표시**

> 데이터를 표시한다는 것은 요소를 화면이나 다른 출력 장치에 렌더링하는 것.

### DOM

- Document Object Model
- 프로그래밍 방식으로 요소를 렌더링하기 위한 방식
  - HTML 요소로 정의된 문서를 트리 형태로 관리

## 렌더링 성능 모니터링

웹용 렌더링 엔진을 설계할 때, 가장 고려해야 할 것들

- 가독성 Readability
- 유지 관리성 Maintainability
- 성능

사용자들은 웹을 통해 화면을 바라보기 때문에 웹 어플리케이션에서 렌더링은 매우 중요한 작업

### 렌더링 성능 모니터링 도구

- 크롬 개발자 도구
- stats.js
- 사용자 정의 성능 위젯
  - requestAnimationFrame 콜백을 이용하여 렌더링 사이클 사이의 시간을 추적하고, 콜백이 불리는 횟수를 추적

## 렌더링 함수

- 순수하게 함수를 사용하여 요소를 DOM에 렌더링하는 방법

  > view = f(state)

### 순수 함수 렌더링

- 책에서는 ToDo-List를 구현하는 예시를 들어 렌더링 과정을 설명한다.
  - 현재 웹을 구성중인 targetElement과 state를 parameter로 받는다.
  - 이를 cloneNode를 통해 복제본을 생성한다.
  - state를 통해 복제본을 업데이트한다.
    - 이때 필자는 `DOM의 수정은 가상임을 명심하자` 라는 말을 하는데, 이후 **React의 Virtual DOM**과 관련지어 설명하는 것이 아닐까라는 생각이 들었다.
    - 복제된 DOM 요소를 수정하면 성능이 향상된다고 한다.
      - 실제 렌더링되어있는 DOM 요소를 건드리는 것은 위험요소가 많기 떄문이지 않을까?
  - 업데이트한 복제본을 실제 DOM에 연결한다.
    - requestAnimationFrame 안에서 replaceWith 메서드를 사용하여 복제본으로 targetElement를 변경한다.
    - requestAnimationFrame을 기반으로 렌더링을 실행하는데, **모든 DOM 조작이나 애니메이션은 이 DOM API를 기반으로 해야 한다**.
      - 해당 API는 **Main Thread를 block**하지 않고, repaint가 이벤트 루프에서 스케줄링되기 직전에 실행된다.
      - Main Thread를 block하지 않는다는 점이 굉장히 효율적이지 않을까?

```tsx
위의 과정을 정리하면 다음과 같다.

* 정적 렌더링 스키마
 브라우저 렌더링 -> 다음 렌더링 대기 -> 새 가상 노드 -> DOM 조작(복제본) -> 브라우저 렌더링
```

### 구성 요소 함수

- 컴포넌트간 상호작용에 올바른 함수를 수동적으로 호출하기 보다는 선언적 방식을 사용하여 시스템이 모든 부분을 자동으로 연결해주는 것이 좋다.
  - 구성 요소의 이름을 data-component 속성으로 태그에 넣어줌
  - regestry 객체에 key 값을 data-component에 넣어준 이름으로 정의하고, value에 view함수를 넣어줌
    - registry는 어플리케이션에서 사용 가능한 모든 컴포넌트의 인덱스
  - 이렇게 만든 registry를 이용하여 등록된 모든 컴포넌트들을 고차함수를 이용한 래퍼 함수에서 한번에 렌더링시킴

## 동적 데이터 렌더링

- 실제 어플리케이션에서는 사용자나 시스템의 이벤트에 의해 데이터가 변경된다.
- 새로운 데이터가 발생할 때마다 가상 요소를 만들고 난 후에 실제 요소를 새로 변경한 가상 요소로 바꾸는 방식을 설명
  - 소규모 어플리케이션에서는 충분한 성능을 발휘하지만, 대규모 어플리케이션에서는 성능 저하를 일으킬 수 있다.

### 가상 DOM

- 선언적 렌더링 엔진의 성능을 개선시키는 방법

  - UI 표현은 메모리에 유지되고, 실제 DOM과 동기화된다.
  - 따라서 실제 DOM은 가능한 한 적은 작업을 수행한다

    **→ Reconciliation**

- 핵심은 diff 알고리즘
  - 실제 DOM과 새로운 DOM을 비교하여 변경사항을 찾아 교체하는 가장 빠른 방법을 찾아낸다.
    - 속성의 수가 다른 경우
    - 하나 이상의 속성이 변경된 경우
    - 자식이 없고 textContent가 다른 경우
    - …

> “시기상조의 최적화는 모든(대부분의) 악의 근원이다.” - 도널드 크누스
