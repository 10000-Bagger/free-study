## 단위 테스트란 무엇일까?

> **단위 테스트 (Unit Test)**

- 앱에서 테스트 가능한 **가장 작은 소프트웨어를 실행해 예상대로 동작하는지 확인**하는 테스트
  - 단일 함수 결과값, 컴포넌트의 상태나 행위 등
- 다른 컴포넌트, 함수 등과의 상호작용보다는 각각의 행위를 독립적으로 검증
- 공통 컴포넌트는 단위 테스트에 적합하다.

### `Arrange-Act-Assert` 테스트 작성 패턴 (AAA 패턴)

> **Arrange**

- 테스트를 위한 환경을 만드는 코드
- 컴포넌트를 렌더링하는 코드 등

> **Act**

- 테스트할 동작을 재현하는 코드
- 컴포넌트 클릭, 키 입력 등의 시뮬레이션

> **Assert**

- 테스트 코드의 동작이 기대했던대로 올바르게 실행되었는지 검증하는 코드

### React Testing Library

- 컴포넌트 테스트를 손쉽게 할 수 있도록 도와주는 라이브러리
- `render`
  - 컴포넌트를 렌더링하는 함수
    - ex) `await render(<Component />)`
  - `render API`를 호출하면 테스트 환경의 `jsDOM`에 리액트 컴포넌트가 렌더링된 DOM 구조가 반영되어 테스트 환경을 조성할 수 있다.
- Query
  - 사용자가 요소 조회를 위한 API
  - 변하지 않는 속성들을 기반으로 조회
    - ex) getByPlaceholderText, getByText, getByTitle, …
- `screen`
  - `document.body` 전체에 대해 쿼리를 할 수 있는 객체
  - render API를 통해 렌더링된 모든 DOM에 대한 쿼리가 가능하다.
    - ex) `screen.getByLabelText('Example')`

✅  모든 테스트 코드에는 가독성을 위해 `Description`을 작성하자.

✅ 내부 DOM 구조나 로직에 영향을 받지 않게 테스팅 라이브러리의 API를 통해 적절한 요소를 검증하자.

✅  컴포넌트의 최종 렌더링 결과물인 DOM 구조가 올바르게 변경되었는지 검증하자.

## 테스트 환경과 매처

### 테스트 프레임워크

- 태스크 러너, 어설션 라이브러리, 플러그인 등 테스트 실행 및 검증에 필요한 환경을 제공하는 도구
  - puppeteer, cypress, jasmine, jest, vitest 등등
- e2e test를 위한 라이브러리를 제외하고는 대부분 Node.js 환경에서 테스트를 실행한다.

### jsDOM

- Node.js 환경에서는 DOM이 존재하지 않기 때문에, Node.js 환경에서도 DOM이 제대로 렌더링되고 있는지 확인하기 위한 환경
- Node.js에서 사용하기 위해 많은 웹 표준을 순수 자바스크립트로 구현한 것
- `screen.debug()` 로 DOM 구조를 확인할 수 있다.

> ✅ **vitest**에서 테스트를 생성하는 방법

- `test`
  - 보통 description에 `test(“if ~~~~”)` 형식으로 작성
- `it`
  - `test`의 alias
  - 보통 description에 `if(”should ~~~~")` 형식으로 작성
- `describe`를 통해 테스트를 **grouping**하여 사용 가능하다.

> vitest의 `expect`

- 테스트의 기대 결과를 반환하는 함수
- 검증 대상에 대한 다양한 **단언(assertion)을 실행**할 수 있다.
  - **단언**은 테스트가 통과하기 위한 조건(기대 결과)을 서술하기 위해 사용
  - ex) `expect(textInput).toHaveClass(’my-class’);`
  - `toHaveClass` 와 같이 테스트를 통과하기 위한 조건을 만족하는지 확인하는 함수를 **Matcher**라고 부른다.
  - vitest에서는 사용자가 커스텀한 matcher를 정의할 수도 있다.

## setup과 teardown

> **“모든 테스트는 독립적으로 실행되어야 한다.”**

- 한 테스트 코드의 변경에 따라 다른 테스트 코드에 영향을 주어선 안된다.
  - 실행 순서에 따라 테스트 코드의 결과가 달라져서도 안된다.
  - 따라서 각 테스트는 독립적으로 실행 결과를 보장할 수 있어야 한다.

> **setup**

- 테스트를 실행하기 전 수행해야 하는 작업
  - `beforeEach`
    - 스코프 내 테스트가 실행되기 전마다 실행
    - 반복적인 컴포넌트 렌더링 패턴에 사용하면 유용
  - `beforeAll`
    - 스코프 내에서 테스트 실행전 한번만 실행
    - 스코프 내에서 전역으로 공유할 환경이나 상태를 설정할 때 사용하면 유용

> **teardown**

- 테스트가 완료된 후 수행해야 하는 작업
  - `afterEach`
    - 스코프 내 테스트가 완료될 때마다 실행
    - 테스트에 의해 생성된 상태를 초기화하는 데에 사용
  - `afterAll`
    - 스코프 내 테스트가 모두 완료된 후에 한번만 실행

✅ 이 둘을 활용해 테스트 시작 전후로 다른 테스트에 영향을 미치지 않도록 데이터 초기화나 세팅을 다시 할 수 있다.

✅ 테스트마다 반복되는 설정 작업을 공통으로 정의하여 효율성을 늘릴 수 있다.

✅ Node.js 환경에서 테스트를 진행하기 때문에 실제 브라우저 환경과의 차이가 존재할 수 있는데, 이때 미리 전역 객체에 필요한 속성을 정의하여 테스트를 진행해야 한다.

✅ 전역 변수를 활용해 조건부로 동작을 분리할 경우, 변수 설정에 따라 테스트 독립성이 깨질 수 있어 좋지 못하다.

## React Testing Library와 컴포넌트 테스트

### React Testing Library

- UI 컴포넌트 테스트를 손쉽게 할 수 있도록 도와주는 라이브러리
- 특정 프레임워크에 종속되지 않는다.
  - React가 아닌 vue와 같은 프레임워크에서도 사용 가능

> **핵심 철학**

- UI 컴포넌트를 **사용자가 사용하는 방식으로 테스트**하자!
- DOM 노드를 조회(쿼리)하고 사용자와 비슷한 방식으로 이벤트를 발생시키자!

> **인터페이스를 기준으로 테스트를 작성**

```tsx
it("버튼을 누르면 모달을 띄운다.", () => {
  user.click(screen.getByRole("button"));
  // ...
});
```

- 내부 구현과 종속성이 없으며 캡슐화에 위반되지 않음
- DOM, 이벤트 인터페이스를 기반으로 검증
- 테스트 코드를 보다 직관적으로 이해할 수 있다.

> `testing-library/user-event` 의 `userEvent`

- 다양한 이벤트를 실제 브라우저에서의 동작과 유사하게 시뮬레이션할 수 있는 라이브러리

> `spy` 함수

- 테스트 코드에서 특정 함수가 호출되었는지, 함수의 인자로 어떤 것이 넘어왔는지 어떤 값을 반환하는지 등 다양한 값들을 저장
