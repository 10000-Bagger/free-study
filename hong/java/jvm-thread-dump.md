# JVM Thread Dump 분석하기

## Thread Dump란?

- Java 스레드는 데몬 스레드와 비데몬 스레드(일반적인 스레드) 2가지로 나눌 수 있다.
- 데몬 스레드: main 스레드(자신에게 요청을 주는 스레드)를 돕는 서포트 역할을 하는 스레드. 즉, main 스레드가 종료되면 데몬 스레드도 강제 종료된다. 마스터-슬레이브 느낌.
- 비대몬 스레드: 데몬 스레드가 아닌 것들. 즉, 자신의 작업을 다른 스레드가 종료되었다고 해서 종료하는 게 아닌 끝까지 수행하도록 되어 있는 스레드
- 이런 스레드들을 말그대로 Dump 퍼온다는 뜻이다. 서버 프로세스에 속한 모든 스레드들의 상태를 분석할 수 있도록 추출한다는 것이다. 서버 프로세스에 속한 모든 스레드들의 상태를 분석할 수 있도록 추출한다는 것이다.

## Thread dump는 언제 작업하는 것인가?

- WAS 서버 (Java Application)의 처리 (응답속도)가 늦을 경우
- WAS 서버의 자원 사용률이 높을 경우
- 서버 Heap Memory가 GC가 일어남에도 불구하고 지속적으로 증가하는 경우

등 많은 이유가 있지만, 모두 성능과 연관되어 있다.

** 관련 추가 자료: [스레드 덤프 분석하기](https://d2.naver.com/helloworld/10963)

## Thread dump가 필요한 이유

- 웹 서버에서는 많은 수의 동시 사용자를 처리하기 위해 수십 ~ 수백 개 정도의 스레드를 사용한다. 두개 이상의 스레드가 같은 자원을 이용할 때는 필연적으로 스레드 간에 경합이 발생하고, 경우에 따라선느 데드 락이 발생할 수도 있다.
- 스레드 경합 때문에 다양한 문제가 발생할 수 있으며, 이런 문제를 분석하기 위해서는 스레드 덤프를 이용해야 한다. 이를 통해 각 스레드의 상태를 정확히 알 수 있다.

### 경합

- 경합은 어떤 스레드가 다른 스레드가 획득하고 있는 Lock이 해제되기를 기다리는 상태를 말한다. 웹 애플리케이션에서 여러 스레드가 공유 자원에 접근하는 일은 메우 빈번하다. 대표적으로 로그를 기록하는 것도 로그를 기록하려는 스레드가 락을 획득하고 공유 자원에 접근하는 것이다.

### 데드락

- 데드락은 스레드 경합의 특별한 경우인데, 두 개 이상의 스레드에서 작업을 완료하기 위해서 상대의 작업이 끝나야 하는 상황을 말한다.

## Java Thread 배경 지식

### 스레드 동기화

- 스레드는 다른 스레드와 동시에 실행할 수 있다. 여러 스레드가 공유 자원을 사용할 때 정합성을 보장하려면 스레드 동기화로 한번에 하나의 스레드만 공유 자원에 접근할 수 있게 해야 한다.
- Java에서는 Monitor를 이용해 스레드를 동기화한다. 모든 Java 객체는 하나의 Monitor를 가지고 있다. 그리고 Monitor는 하나의 스레드만 소유할 수 있다.
- 어떠한 스레드가 소유한 Monitor를 다른 스레드가 획득하려면 해당 Monitor를 소유하고 있는 스레드가 Monitor를 해제할 때까지 Wait Queue에서 대기하고 있어야 한다.

### 스레드 상태

- 스레드 덤프를 분석하려면 스레드의 상태를 알아야 한다. 스레드의 상태는 java.lang.Thread 클래스 내부에 State라는 이름을 가진 Enumerated Type (열거형)으로 선언되어 있다.
    - NEW: 스레드가 생성되었지만 아직 실행되지 않은 상태
    - RUNNABLE: 현재 CPU를 점유하고 작업을 수행 중인 상태. 운영체제의 자원 분배로 인해 WAITING 상태가 될 수도 있다.
    - BLOCKED: Monitor를 획득하기 위해 다른 스레드가 락은 해제하기를 기다리는 상태
    - WAITING: wait() 메서드, join() 메서드, park() 메서드 등을 이용해 대기하고 있는 상태
    - TIMED_WAITING:
        - sleep() 메서드, wait() 메서드, join() 메서드, park() 메서드 등을 이용해 대기하고 있는 상태.
        - WAITING 상태와의 차이점은 메서드의 인수로 최대 대기 시간을 명시할 수 있어 외부적인 변화뿐만 아니라 시간에 의해서도 WAITING 상태가 해제될 수 있다는 것이다.

** 스레드 상태에 대한 오라클 문서: [Thread States for a Thread Dump](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr034.html)

### Thread 종류

- Java 스레드는 데몬 스레드와 비대몬 스레드로 나눌 수 있다.
- 데몬 스레드는 비대몬 스레드가 없다면 동작을 중지한다.
    - 대표적인 예로, static void main(String[] args) 메서드가 실행되는 스레드는 비데몬 스레드로 생성되며, 이 스레드가 동작을 중지하면 다른 데몬 스레드도 같이 동작을 중지하게 된다.

### Thread Dump 획득 방법

- jstack 사용

## Thread Dump 유형 별 패턴

### Lock을 획득하지 못하는 경우 (BLOCKED)

- 한 스레드가 락을 소유하고 있으면, 다른 스레드가 락을 획득하지 못하므로 애플리케이션의 전체적인 성능이 느려진다.

### 데드락 상태인 경우

- 스레드 A가 작업을 계속하려면 스레드 B가 소유한 락을 획득해야 하고, 스레드 B가 작업을 계속하려면 스레드 A가 소유한 락을 획득해야 할 때 발생한다.

### 원격 서버로부터 메시지 수신을 받기 위해 계속 대기하는 경우

- 스레드가 계속 RUNNABLE 상태에 있어 문제가 될 만한 부분이 없는 것처럼 보인다. 하지만 스레드 덤프를 시간순으로 나열하면, `socketReadThread` 스레드가 계속 소켓을 읽으려 무한정으로 대기하고 있는 상태이다.

### WAIT 상태에 있는 경우

- 스레드가 계속 WAIT 상태를 유지하고 있는 경우이다.
- 다음 스레드 덤프 예에서 loWaitThread 스레드는 LinkedBlockingQueue 객체에서 메시지를 획득하기 위해 계속 대기하고 있다. 만약 LinkedBlockingQueue에 메시지가 들어오지 않는다면 해당 스레드의 상태가 바뀌지 않게 된다.

### 스레드 리소스를 정상적으로 정리하지 못하는 경우

- 불필요한 스레드가 계속해서 늘어나는 경우이다. 스레드 리소스를 정상적으로 정리하지 못하고 있는 경우이므로 각 스레드를 정리하는 모습 혹은 스레드가 종료되는 조건을 확인하는 것이 좋다.

## Thread Dump를 이용한 문제 해결 예제

### 상황1: CPU 사용률이 비정상적으로 높을 때

- 애플리케이션을 수행할 때 CPU 사용률이 비정상적으로 높다면 스레드 덤프를 이용하여 문제를 파악할 수 있다.
- 먼저 CPU를 가장 많이 점유하는 스레드가 무엇인지 추출한다.

```
ps -mo pid, lwp, stime, time, cpu -C java
```

- 추출한 결과에서 CPU를 가장 많이 사용하는 LWP (light weight process)와 고유 번호를 확인한다. 고유 번호를 16진수로 변환하면 NID를 얻을 수 있다.
- 그 다음으로 스레드 덤프를 얻어 스레드의 동작을 확인한다. 다음은 PID가 10029인 애플리케이션의 스레드 덤프이다. 이 스레드 덤프에서 NID가 0x2737인 스레드를 찾아 스레드의 동작을 확인한다.
- 스레드 덤프를 시간 별로 여러 번 획득해서 스레드의 동작 상태 변화를 확인해 문제 상황을 추론해야 한다.

### 상황2: 수행 성는이 비정상적으로 느릴 때

- 애플리케이션의 수행 성능이 비정상적으로 느릴 때에는 BLOCKED 상태인 스레드가 원인인 경우가 많다. 이때에는 스레드 덤프를 여러 번 얻은 다음 BLOCKED 상태인 스레드 목록을 찾고 BLOCKED 상태인 스레드가 획득하려는 락과 관계된 스레드를 추출해본다.
- 이런 패턴은 DBMS를 다루는 애플리케이션에서 자주 나타나는 데, 다음은 가장 자주 나타나는 두가지 경우이다.
    - 첫째, 스레드가 계속 동작하고 있지만 DBCP 등의 설정이 적절하지 못해 충분한 성능을 내지 못하는 경우이다. 이 경우에는 스레드 텀프를 여러 번 얻어서 비교하면 BLOCKED 상태에 있던 스레드 중 몇 개는 다른 상태인 경우가 많을 것이다.
    - 둘째, DBMS와 연결이 비정상적인 상태라 계속 타임아웃 시간까지 대기하는 경우이다. 이 경우에는 스레드 덤프를 여러번 추출해 비교해도 DBMS와 관련된 스레드는 계속해서 BLOCKED 상태에 있는 것을 확인할 수 있다. 타임아웃 값 등을 적절하게 변경해서 문제 발생 시간을 줄일 수 있다.
