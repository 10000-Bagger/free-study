# Operation Based CRDT

Operation Based CRDT는 연산 기반 CRDT이다. 상태 기반 CRDT인 State Based CRDT에선, 상태를 주고 받고 병합했다. <Br>
예를 들어 어떤 하나의 1000줄짜리 글을 생각해보자. 이 글을 여러명이 동시에 편집할 수 있고, CRDT는 편집된 부분들을 충돌 없이 잘 합치는게 목표일 것이다. State Base CRDT에선 이 글 전체 혹은 일부를 계속해서 주고 받는다. 즉, "상태"를 주고 받는 것이다. <Br>
따라서 큰 상태를 주고 받을 수 밖에 없고, 이는 성능적으로 문제가 된다. 다른 해결 방법도 있다지만, ([Delta State Replicated Data Types](https://arxiv.org/pdf/1603.01529)) 이번엔 Operation Based CRDT에 대해 알아보자. <Br>

# 1. Commutative Replicated Data Types (CmRDT)
Operation Based CRDT는 말 그대로 연산을 주고 받는 형태의 CRDT이다. Commutative Replicated Data Types (CmRDT 혹은 CRDT) 이라고도 불리며, **어떤 위치에 어떤 연산이 일어났는지에 대한 정보를 주고 받음으로써, 송수신되는 데이터 량을 대폭 줄일 수 있다.** 이를테면, `Hello World!`에서 다섯 번째 글자인 `o`를 뺀다고 생각할 때, 상태 기반은 o만 빠진 `Hell World!`를 주고 받겠지만, Operation Based에선 `5번째 문자를 삭제함`와 같은 연산 정보만 주고 받는 것이다. <br> 
이 방법은 당연히 전문을 주고 받는 방식 보다 훨씬 가볍고, 비교하는 과정도 쉽다. **더욱 간단하고 효율적인 데이터 타입을 구현할 수 있다.** <br> 

**그 대신 동기화와 전파가 더 어렵고, 연산만으로 문서를 변경하기 때문에 문제가 생겼을 때 원래대로 돌리기 위한 복구 작업이 복잡하고 어려울 수 있다.** <br> <br>

State Based CRDT에서는 "복제"가 별로 문제되지 않았다. "결합 법칙", "교환 법칙"을 만족하고 "멱등성"을 갖는 병합 연산자를 활용하기 때문에 복제 자체는 그리 어렵지 않았다. 하지만 연산 기반 CRDT에서는 각 연산들을 정확하게 동기화하고, 전파하는 것이 더욱 복잡하다. 

# 2. Protocol
Operation Based CRDT에서 사용되는 핵심 복제 프로토콜은 Reliable Causal Broadcast라고 부르는데 줄여서 RCB Protocol이라고 부른다. 이것은 어떤 알고리즘이라기 보다는, 이 프로토콜이 만족해야 하는 요구사항들의 집합니다. <br>
RCB는 아래와 같은 조건을 만족해야 한다.

1. Reliability (신뢰성)
2. Causality (인과성)
3. Replication (복제)

## 2.1 Reliablity
Reliablity란 Local에서 보이는 모든 업데이트는 항상 다른 사람들에게도 보여야 한다는 것이다. 네트워크 연결이 끊기는 상황일지라도 이 조건을 만족해야 하기 때문에, Reliablity는 달성하기 힘든 조건중 하나이다. <br> 
그러니까 어떤 유저가 로컬 상태를 업데이트 했는데, 이후 시스템이 껐다가 켜지는 상황이 일어나더라도 이 Update들을 다른 유저들에게 (Peer) 전송해야만 한다. 그렇지 않으면 당연히 서로 내용이 일치하지 않는 문제가 발생한다. <br>

CRDT 외에도 기존의 분산 이벤트 로그에서도 전체 순서에 대한 조정이 필요했다. 하지만 이는 독립적으로 이벤트 순서를 설정할 수 없으며, 오프라인 모드에서는 작동하지 않는다. <Br> <br>

각 노드가 독립적으로 이벤트를 기록하면서, 전체 이벤트들의 "정확한" 순서를 전체 노드가 공유하는 어딘가에 기록하는 것은 불가능 하다고 한다. 글에선 "케이크를 먹으면서 동시에 가질 수는 없다." 라고 비유했는데, 와닿는지는 모르겠다. <br>

**우리가 할 수 있는 최선은 인과 순서 형태의 "부분적인 순서"라고 한다.** 구체적인 예시들과 이 내용을 더 이해해보자.

### 2.1.1 단일 노드나 Actor의 범위 내에서 이벤트의 순서를 보장할 수 있다.
**단일 노드나 Actor의 범위 내에서 이벤트의 순서를 보장할 수 있다.** (인과 순서 형태의 부분적인 순서) <br> 
에를 들어 진호가 "치"라는 글자와 "킨"이라는 글자를 입력하면 내 메시지를 읽는 모든 사람들은 "'치'가 '킨'보다 먼저 발생했구나"라고 알 수 있다.

### 2.1.2 동시 업데이트의 순서를 보장할 수 없다. 
**동시 업데이트의 순서를 보장할 수 없다.** <br>
진호가 "치킨"을 쓰고 어디에선가 호진이가 동시에 "피자"라고 썼다. 이후 서로의 이벤트를 복제한다고 생각해보자. 완전히 동시에 작성한 경우, 혹은 조금 차이 나더라도 몇몇 경우엔 어떤 사람에겐 `치킨 -> 피자`로, 어떤 사람에겐 `피자 -> 치킨`으로 보일 수 있다. <br>
이런.. 독립적으로 작업하고, 동시 업데이트 하는 경우 순서를 보장할 수 없다.

### 2.1.3 한 이벤트가 다른 이벤트를 발생시킬 수 있는 경우 이벤트의 순서를 보장할 수 있다.
한 이벤트가 다른 이벤트를 발생시킬 수 있는 경우 이벤트의 순서를 보장할 수 있습니다. **때문에 "인과성"이라는 이름이 붙은 것이다!** <br> 

1. 진호가 "치"를 작성하고, 이를 우석이와 홍석이 노드에 복제했다.
2. 우석이는 "치"를 받은 후 "맥"이라고 답장을 보냈고, <br> 홍석이는 "치"를 받은 다음 "킨"라고 응답했다. 
3. 아직 "맥"과 "킨"은 복제되지 않은 상태이다.
4. 이제 참여자들이 발생시킨 모든 이벤트를 복제한 다음, 가능한 순서는 `치맥킨` 또는 `치킨맥`으로 2가지 일 수도 있지만, <br>
**"맥"과 "킨"이 "치"보다 먼저 보이게 되는 일은 절대 없을 것이라고 보장할 수 있다!** This means that we will never see an answer before question it refers to. 즉 답변 보다 질문을 먼저 말할 수는 없는 것과 같다. (만화 원피스 세상에서는 다를 수 있으니 주의해야 한다.)


<br> <br>

### 부분 순서는 멀티버스다

![image](https://github.com/user-attachments/assets/df67da8c-3e4f-4e5c-a56a-979a1759e4c5)

여기서 일종의 "타임라인"을 떠올려 보자. 보통 어떤 사건의 타임라인이라면 선형적으로 이루어질 것이다. **하지만 이 "부분 순서"는 멀티 버스처럼 수형도와 같은 형태가 될 것이다.** "치맥킨"인 우주와 "치킨맥"인 우주가 있다는 것이다! <br>
동시 업데이트는 새로운 브랜치가 만들어지는 것이며, 복제는 브랜치 병합처럼 생각하면 된다. <br>

전체 순서를 "설정" 하기 위해 인기있는 기술은 타임스탬프를 활용하는 것이다. DB에 데이터를 저장할 때 Sequencial한 ID를 만들듯이 일련 번호를 주거나, 날짜 및 시간을 이용해 순서를 정하는 것이다. **하지만, 타임스탬프 하나만으로는 동시에 발생한 이벤트들의 순서를 제대로 인식할 수 있기엔 부족하다.** (또한 자주 언급한대로 날짜 및 시간은 측정하는 환경에 따라 다를 수 있으므로 좋지 않다.) <br>

이에, 벡터 클록을 활용하면 좋다. <br>
간단한 개념은 이 글 참고 -> [LLWRegister와 Lamport Clock](https://github.com/10000-Bagger/free-topic-study/blob/main/jin/%5BCRDT%5D%20LLWRegister%EC%99%80%20Lamport%20Clock.md)을 참고

### 벡터 클록 활용 시나리오
