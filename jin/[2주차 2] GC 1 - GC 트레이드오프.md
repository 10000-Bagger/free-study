# GC

오라클은 JVM에 대해 그리 많은 것을 정해두지 않는다. "스펙"으로서 존재한다. <br>
마치 인터페이스를 선언하듯, 단지 "OS에 맞게 바이트 코드를 실행할 수 있는" 추상적인 형태의 해석 머신이라고만 정해두었고, 다양한 회사들이 그 "구현체"를 만들어 두었다. <br> <br>

인터페이스가 그러하듯, 이러한 스펙 선언 방식은 구현에 엄청난 자유를 부여하는데, JVM은 하드웨어의 형태여도 상관 없고, JAVA가 아닌 다른 언어를 컴파일 이전의 언어로 사용해도 된다. <br>

최근에 사용해본 코틀린 부터 스칼라, 그루비, JRuby, 자이썬 등등.. 다양한 언어가 JVM에 의해 해석된다. 바이트 코드를 해석 가능하기만 하면 장땡! <br> <br>


# GC 트레이드 오프
JVM이 그러할진데 GC 또한 구현법에 대한 자세한 설명이 없다. 그 스펙이 상세히 기술되어 있지 않는데, 단지 **"객체용 힙 공간은 GC라는 자동 저장소 관리 시스템으로 회수된다. 어떤 일이 있어도 객체를 명시적으로 해제해서는 안된다."** 라고만 짧게 적혀있다. <Br> (심지어 GC가 없는 Lego Mindstorms라는 JVM도 있음!) <br> <br>

GC 알고리즘 또한 매우 형태가 다양한데, 범용적으로 어떤 GC가 모든 상황에서 낫다! 이런건 없고, 결국 다 트레이드 오프다. **"우리 상황에서 뭐가 가장 나은지"** 를 따져야 한다. <Br> <br>

여러가지 예를 들어보자. JVM은 GC를 수행시키기 위해 잠시 어플리케이션을 멈추는데 이를 STW(Stop-The-World) 중단이라고 부른다. <br> 

카카오톡과 같은 서비스는 실시간으로 엄청난 양의 작업을 처리하기 때문에, STW로 인해 어플리케이션이 멈추는 시간이 긴 경우 치명적인 피해를 입게 된다. <Br> 반면, 배치 잡을 수행하는 어플리케이션은 중단 시간의 길이는 크게 중요하지 않다. 물론 중요하지. 중요하지만, 중단 시간이 짧은 알고리즘 보다, CPU 효율 및 처리율이 우수한 GC 알고리즘이 있다면 그 알고리즘을 선택할 것이다. <br> 
또 그래픽이나 애니매이션 디스플레이 시스템은 프레임률이 웬만하면 고정되어 있기 때문에, 규칙적으로 GC를 수행할 수 있다. <br> 하지만 대부분의 서비스들은 "언제" GC를 수행하는 것이 적절한지 정해져 있지 않다. GC는 그저 "필요할 때" 작동하는데, 이런 예측 불가능성이 중단으로 인한 지연보다도 더 문제인 서비스들이 있다. <br> 그런 서비스들은 STW를 최대한 줄인 최신 GC들을 사용해야 한다. <Br> <br>

개발자는 우리 서비스에 맞는 GC를 선택하기 위해 아래의 요소들을 고려해야 한다.

1. 중단 시간
2. 처리율 (Application 런타임 대비 GC의 시간 비율)
3. 중단 빈도
4. 메모리 회수 효율 (GC 사이클당 얼마나 많은 가비지가 수집되는지?)
5. 중단 일관성 (중단 시간이 고른지?)


<br>
