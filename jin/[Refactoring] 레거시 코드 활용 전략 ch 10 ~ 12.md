# 10. 테스트 하네스에서 이 메서드를 실행할 수 없다.

테스트 하네스에서 어떤 메서드를 실행할 수 없는 경우는 어떤 경우일까?

이번 장에서는 아래 4가지 케이스 중 1번에 대해 이야기 한다.

1. 캡슐화 - 접근 제한으로 인해 접근할 수가 없다.
2. 메서드 호출에 필요한 매개변수를 생성하기 어렵다.
3. 메서드 실행시 부정적인 부작용이 발생한다.
    
    예를 들어 테스트시 핵미사일이 발사되거나, DB 데이터가 변경된다.
    
4. 메서드가 사용하는 객체들을 사전에 감지해야 하는 경우
    
    → 아마 내부적으로 사용하는 값을 미리 알아야 하는 경우를 말 하는 것 같다. 
    
    예를 들어 어떤 “랜덤 값”이나, “현재 시간”을 내부에서 생성해 사용하는 경우, 미리 알기가 힘들다. 이 경우 확실히 테스트 하기 나쁘다. 이 단원에서 이 내용에 대해 많이 다루지 않지만, 나는 이러한 문제를 의존성 주입이나, 의존성 역전으로 해결해왔다. 
    
    개인적으로 생각했을 때 중요한 내용이다.
    

## 10.1 숨은 메서드

클래스 내의 메서드를 변경하기 위해 테스트 해보고 싶다. 이 때 메서드가 private인 경우 어떻게 대처해야 하는가?

1. 해당 private method를 호출하는 public method에서 충분히 테스트 가능한 상황 
    
    → 그냥 테스트 하면 된다.
    
2. 테스트 요구사항 떄문에, 1번과 같은 테스트가 불가능한 상황
    
    → 메서드를 public으로 만들면 된다??????
    

테스트를 위해 메서드를 public으로 만드는게 과연 괜찮은 걸까?

이 책의 주장을 확인해보자.

## 10.2 당신이 private 메서드를 public으로 만들기 싫은 이유

이 책에서 주장하는 내가 private 메서드를 public으로 만들기 싫은 이유는 아래와 같다고 한다.

1. 메서드가 단순히 유틸 함수이기 떄문에. 즉, 호출 코드는 이 메서드를 신경쓰지 않는다.
    
    → 책에서 말을 너무 어렵게 했는데, 호출할 private method가 단순 유틸 메서드이고, private method를 사용하는 public method를 호출하는 쪽에서 저 private method를 신경 쓰지 않기 때문에 public으로 바꾸는게 꺼려질 수도 있다는 말인 것 같다.
    
2. 호출 코드에서 이 메서드를 직접 사용하는 경우, 클래스의 다른 메서드의 결과 값에 영향을 미칠 수 있다.
    
    → 여기도 말을 너무 어렵게 해놨는데, private였던 메서드를 public으로 바꾸면 외부에서 호출할 가능성이 늘어 난다는 것이다. 나도 이 지점이 걱정된다.
    

이 책에서 말하는 2번의 해결책은 private method를 다른 클래스 B에 분리한 다음 public mehtod로 바꾸라는 것이다. 이후 원래 private method를 가지고 있던 A 클래스에서 이 B 클래스 인스턴스를 만들고 메서드를 호출하라는 것이다. 이렇게 하면 확실히 테스트 작성은 쉬워진다.

## 10.3 내 생각

나는 책에서 추천하는 방식중 접근 제한자를 바꾸는 방식이 적절한 방법인지 모르겠다.

이 책에서는 접근 제한자를 바꾸는 것과 내부 의존성을 주입 받도록 만들면서 캡슐화를 위반하는 것을 테스트 구성에 있어 유용하다고 언급한다. 캡슐화의 목적은 살펴볼 곳을 줄여 코드를 추론하는데 도움을 준다고 말하는 것인것 같다.

나도 의존성을 주입 받도록 만드는 것은 좋다. 하지만 오로지 private method를 테스트 하기 위해 접근 제한자를 바꾸는 방식이 적절한지는 모르겠다. 

나 또한 저자의 말대로 영향 범위나 상태의 변경 가능성을 최대한 줄이기 위해 접근 제한자를 적극적으로 활용하는 편이다. 어디서 의존하고 있는지 더 쉽게 파악할 수 있는 것을 넘어, 무분별한 못한 의존을 줄일 수 있고, 사용법을 강제할 수도 있어서 좋다고 생각한다. 프로젝트는 필연적으로 여러 명이서 하게 된다. 그리고 어떤 메서드를 public으로 두었다면, 다른 사람도 이 메서드를 언제든 호출할 수 있기 때문에 예상하지 못한 사용이 늘어날 수 밖에 없다. 여기까지는 동의한다.

하지만 나는 캡슐화를 특정 메서드 사용을 강제할 떄도 활용한다.

순수한 자바로 싱글톤을 구현할 때나, 정적 팩터리 메서드를 쓰기 위해 생성자의 공개 범위를 제한한다. 또한 어떤 인터페이스의 구현체를 만들 때, 메서드를 구현하는 과정에서 사용되는 내부 적인 계산들을 외부에서 직접 사용하지 않길 바랄 때, 즉 오로지 내가 공개한 인터페이스 메서드만 사용하길 원할 때, 접근 제한자를 활용한다. 이것은 매우 유용하다. 

접근 제한자를 사용하는 이유는 정말 다양하고, 저자가 말하는 캡슐화를 사용하는 목적 외에도 나는 여러 용도로 접근 제한자를 활용한다. 떄문에 모든 상황에서 기능 테스트를 하기 위해 접근 제한자를 바꾸는 것은 조금 반대한다.

# 11. 코드를 변경해야 한다. 어느 메서드를 테스트 할까?

결국 리펙토링을 위한 테스트 코드는 “코드를 변경 하기 전, 후에도 여전히 똑같이 동작하는가?”가 궁금한 것이다. 그렇다면, 코드가 영향을 미치는 지점이 바로 테스트 코드의 최적의 위치라고 할 수 있겠다.

우리가 리팩토링과 테스트 작성시 고려해야 하는 것들은 아래와 같다. 

- 리펙토링을 진행할 떄는 객체가 미치는 영향을 추론한다.
- 테스트를 작성할 때는 반대로 객체들이 제대로 동작하지 않을 경우 어떤 일이 생길지 생각한다.

이제 객체가 영향을 미치는 범위를 추측해보자.

## 11.1 객체가 영향을 미치는 부분

기본적으로 객체와 객체의 상호작용은 아래와 같은 방법으로 이루어진다.

1. 호출되는 객체에게 인수로 상태를 전달한다.
2. 반환 값을 통해 호출 객체에게 상태를 전달 받는다.

위 2가지 방법을 통해 기본적으로 객체와 객체는 소통하고, 서로에게 영향을 미치게 된다.

특히 호출하는 쪽의 변경 보다는 호출 되는 쪽의 변화가 외부에 영향을 미친다.

그리고 다른 다른 방법으로 영향을 미칠 수도 있다.

1. 정적 또는 전역 상태의 변경 (DB 데이터나, 상속 된 상태도 포함될 수 있겠다)
2. AOP 를 통한 영향

우리가 유심히 봐야 할 곳들은 이 4가지의 영향을 일으키는 곳들이다.

메서드가 매개변수를 통해 전달 받은 상태를 변경 시키는 곳,

반환값을 외부에 전달하는 곳,

정적 또는 전역 상태를 변경하는 곳,

AOP가 적용되는 joinpoint들

결국 이 4가지 지점에서 변화가 일어나기 때문이다.

리팩토링시 객체가 영향을 미치는 부분들을 관찰하기 위해 저자는 아래의 순서를 따라 영향을 파악한다.

1. 변경 대상 베소드 식별
2. 메서드가 반환값을 가지는 경우, 이 메서드를 호출하는 곳을 찾는다.
3. 메서드가 변경하는 상태가 있다면 살펴본다. 이 상태들을 사용하는 메서드를 살펴본다.
4. 인스턴스 변수나, 슈퍼 클래스, 서브 클래스도 살펴본다.
5. 매개변수로 전달 받은 상태나 수도 있고, 반환 값이 되는 객체를 변경하는지 살펴본다. 
6. 정적이거나 전역적인 상태를 변경하는지 확인한다. 

# 12. 클래스의 의존 관계를 반드시 없애야 하는가?

저자는 어렵게 의존 관계를 모두 끊는 것 외에도 다른 방법을 제안한다.

바로 상위 수준 테스트이다.

하나의 메서드 A가 여러 메서드의 조합일 때, 내부의 메서드들을 테스트하기 힘들다면 A를 테스트 할 수 있다. 단 내부 메서드들의 단위 테스트를 대체하라는 것은 아니다. A를 통해 이들을 테스트 해보라는 뜻이다.

이떄 내부의 메서드들이 변경되는 경우 우리는 어디서 변화를 감지할 수 있을까?

접근 제한자를 바꾸지 않는 이상 아무래도 A가 반환되는 곳일 것이다.

이렇게 특정 변경에 대한 영향을 감지할 수 있는 곳을 “교차 지점”이라고 한다.

우리는 교차 지점을 테스트 함으로써, 내부의 메서드들을 어느 정도 테스트 할 수 있는데, 최대한 가까운 지점에 테스트 해야한다.
