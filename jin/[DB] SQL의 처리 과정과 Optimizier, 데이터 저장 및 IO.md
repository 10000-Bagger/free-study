# 1. SQL의 처리 과정과 I/O
# 1.1 SQL 파싱과 최적화

DB 옵티마이저는 왜 필요한걸까? 그리고 안에서 어떤 일들이 일어날까? <br>

## 1.1.1 Structured Query Language
SQL이란 Structured Query Language의 줄임말이다. "구조적" 질의 언어라는 뜻을 가지고 있는데, SQL문을 생각해보면 아래와 같이 절차적이 아닌 구조적으로 작성 되어 있다.  <br>

```sql
SELECT G.TITLE, G.DESCRIPTION, L.NAME
FROM GOAL G, LIFEMAP L
WHERE G.LIFEMAP_ID = L.ID
ORDER BY G.CREATED_AT DESC
```

SQL은 기본적으로 구조적이지만, 결과물의 집합을 만들 때는 절차적일 수 밖에 없다. DB의 어딘가에서 SQL을 읽어낸 다음 결과물의 집합을 만들기 위해 여러가지 행위를 수행할 것이다. <br>
어떤 테이블을 가져온 다음, 어떤 인덱스를 사용하고, 어떻게 스캔하라 등 절차적인 명령을 내릴 것이다. 즉, 일종의 프로시저가 필요한 셈인데, 이런 프로시저를 만드는 DBMS의 엔진이 SQL 옵티마이저이다. **우리가 쿼리를 작성하면 옵티마이저가 대신해 데이터를 가져오기 위한 코드를 짜 준다고 생각하면 된다.** 그리고 DBMS 내부에서 프로시저를 작성해 실행 가능한 상태로 컴파일 하는 이 과정을 **"SQL 최적화"** 라고 부르는 것이다. <br> 


## 1.1.2 SQL 최적화
DBMS는 SQL을 실행되기 전 위해 SQL 파싱과 최적화 과정를 시행한 다음 로우 소스를 만들어낸다.

1. `SQL 파싱` : 클라이언트로부터 SQL을 전달 받은 다음, SQL 파서가 파싱을 시작한다. <br>
   1. 파싱 트리 생성 : 우리가 사용하는 PL들에서도 똑같이 일어나는 과정으로, SQL문을 이루는 요소들을 분석해 파싱 트리를 생성한다.
   2. Syntax 체크 : 트리를 만들었으니, 문법적 오류를 검사한다. 사용할 수 없는 키워드를 사용하거나 순서가 잘못됐다면 이때 검출된다.
   3. Semantic 체크 : 의미상 오류가 없는지 확인한다. 문법 자체는 옳은데, 존재하지도 않는 테이블이나 컬럼에 쿼리를 날릴 수도 있고, 권한이 없을 수도 있다. 이 모든 의미적 오류를 체크한다.
2. `SQL Optimizier` : Optimizier가 수행. Optimizier는 미리 수집해둔 시스템 및 통계 정보들을 활용해서 다양한 실행경로를 생성한다. 그리고 그 중 가장 효율적인 실행 경로를 선택한다. 마치 네비게이션이 길을 찾기 위해 여러 경로를 탐색하고 Best 경로를 찾는 과정과 동일하다. Optimizier가 수행하는 이 최적화 과정이 DB 성능을 결정하는 가장 핵심적인 부분이다.
3. `로우 소스 생성` : Row-Source Generator가 수행한다. SQL Optimizier가 선택한 실행경로를 실제 실행 가는한 코드나 프로시저로 포맷팅해 Raw Source를 생성한다.

## 1.1.3 SQL Optimizier와 실행계획
SQL Optimizier는 DBMS의 핵심 엔진으로, **사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 Access 경로를 선택한다.** 정말 자동차 네비게이션과 그 역할이 비슷하다. <br> <br>

차를 빌려 멀리 여행을 간다고 생각해보자. 우리는 네비게이션에 목적지를 입력한다. 그러면 네비게이션은 다양한 "비용"을 계산해 여러 경로를 만들어 준다. 보통 운전자에게 이 비용은 "시간"이다. 네비게이션은 여러 경로를 확인한 다음 가장 "빨리" 가려면 어떤 경로를 이용해야 하는지 알려준다. 우리는 여러 경로들 중 원하는 경로를 선택할 수 있다. <br> <br>

SQL Optimizer도 똑같다. 사용자가 어떤 작업을 수행하겠다고 말하면 Optimizier는 "데이터 딕셔너리"라는 곳에 미리 수집해둔 시스템 및 통계 정보들을 활용해서 다양한 실행경로를 생성한다. 그리고 각 경로의 "비용"을 계산해 최소 비용을 갖는 경로를 찾아내는데 **DBMS가 이때 "비용"으로 여기는 것은 I/O 횟수 혹은 실행 시간이다.** <br>
결국 Application 개발시에도 가장 병목이 되는 지점중 하나가 바로 I/O이다. Disk에서 데이터를 가져오건, 외부 서버에서 데이터를 가져오건, I/O는 요청을 받기까지 보통 오랜 시간이 소요되며, 그동안 스레드를 멈춰버리기 때문에 거의 대부분의 병목의 원인은 I/O이다. 그래서 DBMS가 비용을 계산할 때 I/O 횟수를 중요하게 여기는 것이다. <br> <br>

그렇게 만들어진 경로들을 실행계획 - Execution Plan이라고 부른다. 네비게이션에서 처럼 "이런 쿼리는 이런 경로로 가겠습니다"라고 알려주는 역할을 한다. 각종 DBMS 콘솔을 사용해 봤다면 알겠지만, 실행계획은 쉽게 확인해볼 수 있다. 수행 예상 시간은 어떤지, I/O는 얼마나 일어날 것 같은지, Table Full Scan인지 인덱스를 활용하는지 등 쿼리 수행 계획을 알려준다. <br>

### 이 또한 예상 값일 뿐이다.
주의해야 할 점은 이 또한 예상값일 뿐이라는 것을 알아야 한는 것이다. 내비게이션과 똑같이 옵티마이저가 알려주는 예상 Cost는 정말 예상치일 뿐이다. 실제 결과는 다를 수 있다.


## 1.1.4 Optimizer 힌트
우리가 여행을 할 때 어딘가를 경유해서 가고 싶을 수도 있다. 어떤 휴게소에 있는 호두과자가 꼭 먹고 싶다던지, 어떤 고속도로의 길가에 심어진 꽃 나무를 보고 싶을 수도 있다. 이럴 때 우리는 내비게이션에 경유지를 선택한다. 혹은 내비가 더 느린 길을 알려줄 때도 있다. 어떤 동내에서 오랜 시간 일해온 택배 기사님이나 택시 기사님들은 내비도 모르는 좋은 지름길을 알 수도 있다. 이런 경우 그 경로를 사용하라고 내비에게 알려줄 수 있다면 참 좋을 것이다.  <br> <br>

Optimizer에도 똑같이 꼭 거쳐야 할 곳들에 대한 지시를 내릴 수 있다. 이를 "옵티마이저 힌트"라고 부른다. <br>
옵티마이저도 완벽하지 않기 때문에, 어떤 인덱스를 꼭 사용할 것, 어떤 Join을 꼭 사용할 것 등을 지정해줄 수 있다. 업무 특성이나 데이터의 특성을 이해하고 있는 것은 사용자이므로, "어떻게 가라" 힌트를 주는 것이다. <br> <br>

사용법은 주석 기호에 +를 붙인다. (다른 방법도 있지만, 실수하기 쉬워 권하지 않는다.)  <br>

```sql
SELECT /*+ INDEX(G GOAL_PK) */
  G.TITLE, G.DESCRIPTION, L.NAME
FROM GOAL G, LIFEMAP L
WHERE G.LIFEMAP_ID = L.ID
ORDER BY G.CREATED_AT DESC
```

(참고로 오라클 문법이다.) <br>


오라클 힌트는 그 종류가 아주 많다. 다 이해하려고 하기 보단 주의점과 자주 사용하는 힌트를 알아두자. 나도 "이런걸 할 수 있구나" 정도로 이해하는 것이 목표이다. <br>

## 1.1.5 옵티마이저 힌트 사용시 주의해야 할 점
오라클 힌트를 사용할 때의 주의점을 알아보자.

1. 힌트의 인자들 사이엔 콤마 - `,`가 있고, 힌트와 힌트 사이엔 없어야 한다.
  ```sql
  /*+ INDEX(G GOAL) INDEX(L, L_XXX) */ -> 문제 없음
  /*+ INDEX(G), INDEX(L) */ -> 첫 번째 힌트만 적용된다.
  ```
2. 테이블 지정시 스키마명까지 명시하면 안된다. 아래 힌트는 무효다.
  ```sql
  SELECT /*+ FULL(SCOTT.EMP) */
  FROM EMP
  ```
3. FROM 절 옆에 ALIAS를 지정한 경우, 힌트에도 ALIAS를 사용해야 한다. 아래 힌트는 무효다.
  ```sql
  SELECT /*+ FULL(EMP) */
  FROM EMP E
  ```
4. 옵티마이저는 신이 아니다 - 중요한 쿼리이고, 힌트를 줄 거면 빈틈없이 기술하자.
  옵티마이저도 실수할 수 있다. 아주 정확하게 최선의 경우를 늘 찾아내지 않기 때문에, 옵티마이저의 작은 실수가 큰 손실을 끼치는 경우 직접 **힌트를 주는 것도 좋다. 그리고 주려면 빈틈없이 주자.** 무슨 말이냐면, "서울에서 부산까지 갈건데 중간에 대전 성심당을 거쳐줘" 정도로 힌트를 준다면 아마도 서울-성심당, 그리고 성심당-부산의 루트를 내비가 자유롭게 짤 것이다. 만약 작은 실수라도 용납되지 않는 상황의 경우 "성심당-부산"의 루트에서 옵티마이저가 얼마든지 잘못 판단할 수 있다. 따라서 이런 경우 힌트를 아주 자세하게 줘야 한다. 어떤 고속도로를 타고, 어느 도로를 이용하고.. 정확하게 알려줄 필요가 있다. 


## 1.1.6 자주 사용하는 힌트들
자주 사용하는 쿼리 힌트들을 간략하게 알아보자. <br>

### 1. 최적화
1. `/*+ ALL_LOWS */` : 전체 처리속도 최적화
2. `/*+ FIRST_ROWS(N) */` : 최초 N건 응답속도 최적화

### 2. 엑세스 방식
1. `/*+ FULL *` / :인덱스를 타지 말고 테이블 풀스캔 수행
2. `/*+ INDEX */` : 인덱스를 사용할 것
3. `/*+ INDEX_DESC */` : 인덱스를 ORDER BY DESC 역순으로 실행할 것
4. `/*+ INDEX_FFS */` : INDEX FAST FULL SCAN
5. `/*+ INDEX_SS */` : INDEX SKIP SCAN

### 3. 조인 순서 힌트
1. `/*+ ORDERED */` : FROM절에 나열된 테이블 순서대로 조인
2. `/*+ LEADING */` : 내가 힌트절에 열거한 테이블 순서대로 조인
  - 예시 : `/*+  LEADING (A B C) */` -> A, B, C 순서대로 조인
3. `/*+ SWAP_JOIN_INPUTS */` : 해시조인의 경우, BUILD INPUT를 명시적으로 선택
  - 예시 `/*+ SWAP_JOIN_INPUTS(A) */` -> 해시 조인의 경우 BUILD INPUT과 PROBE에 대한 순서 선택이 가능하다.

### 4. 조인 방식 힌트
1. `/*+ USE_NL *` / :NL JOIN (NESTED LOOP - 중첩루프)
2. `/*+ USE_MERGE */` : SORT MERGE JOIN
3. `/*+ USE_HASH */` : HASH JOIN
4. `/*+ NL_SJ */` : NL SEMI JOIN
5. `/*+ MERGE_SJ */` : SORT MERGE SEMI JOIN
6. `/*+ HASH_SJ */` : HASH SEMI JOIN

### 5. 서브 쿼리 팩토링
1.  `/*+ MATERIALIZE */` : WITH 문으로 정의한 집합을 물리적으로 생성하
  - 예시 : WITH /*+ MATERIALIZE*/ T AS (SELECT ...)
2.  `/*+ INLINE */` : WITH 문으로 정의한 집합을 물리적으로 생성 X, INLINE 처리
  - 예시 : WITH /*+ INLINE*/ T AS (SELECT ...)

### 6.쿼리 변환
1.  `/*+ MEERGE */` : 뷰 머징 유도
1.  `/*+ NO_MERGE */` : 뷰 머징 방지
1.  `/*+ UNNEST */` : 서브쿼리 UNNESTING 유도
1.  `/*+ NO_UNNEST */` : 서브 쿼리 UNNESTING 방지
1.  `/*+ PUSH_PRED */` : 조인 조건 PUSHDOWN 유도
1.  `/*+ NO_PUSH_PRED */` : 조인 조건 PUSHDOWN 방지
1.  `/*+ USE_CONCAT */` : OR 또는 IN-LIST조건을 OR-EXPANSION으로 유도
1.  `/*+ NO_EXPAND */` : OR 또는 IN-LIST 조건에 대한 OR-EXPANSION방지

### 7.병렬처리
1.  `/*+ PARALLEL */` : 테이블 스캔, DML 병렬방식으로 처리하도록 할때 사용.. 단일 대형 테이블의 접근시 정말 많이 쓴다.
  - 예시 : /*+ PARALLEL(T1 4)*/
1.  `/*+ PARALLEL_INDEX */` : 인덱스 스캔을 병렬방식으로 처리하도록 유도
1.  `/*+ PQ_DISTRIBUTE */` : 병렬수행시 데이터 분배방식 결정
  - 예시 : `PQ_DISTRIBUTE(T1 HASH(--BUILD INPUT) HASH(--PROBE TABLE))`

### 8. 그외 기타
1.  `/*+ APPEND*/` : DIRECT PATH INSERT유도로 INSERT 문에 주로 많이 쓴다
1.  `/*+ DRIVING_SITE */` : DB LINK REMOTE쿼리에 대한 최적화 및 실행 주체 지정 (LOCAL 또는 REMOTE)
1.  `/*+ PUSH_SUBQ */` : 서브쿼리를 가급적 빨리 필터링하도록 유도
1.  `/*+ NO_PUSH_SUBQ */` : 서브쿼리를 가급적 늦게 필터링 하도록 유도
2.  


# 1.2 SQL 공유와 재사용 - Hard Parsing과 Soft Parsing
